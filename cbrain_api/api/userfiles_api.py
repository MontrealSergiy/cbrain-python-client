# coding: utf-8

"""
    CBRAIN API

    API for interacting with the CBRAIN Platform  # noqa: E501

    OpenAPI spec version: 6.2.0.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from cbrain_api.api_client import ApiClient


class UserfilesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def userfiles_change_provider_post(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Moves the Userfiles from their current Data Provider to a new one.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_change_provider_post(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to move. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userfiles_change_provider_post_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
        else:
            (data) = self.userfiles_change_provider_post_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
            return data

    def userfiles_change_provider_post_with_http_info(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Moves the Userfiles from their current Data Provider to a new one.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_change_provider_post_with_http_info(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to move. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['multi_userfile_mod_req']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userfiles_change_provider_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'multi_userfile_mod_req' is set
        if self.api_client.client_side_validation and ('multi_userfile_mod_req' not in params or
                                                       params['multi_userfile_mod_req'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `multi_userfile_mod_req` when calling `userfiles_change_provider_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'multi_userfile_mod_req' in params:
            body_params = params['multi_userfile_mod_req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BrainPortalSession']  # noqa: E501

        return self.api_client.call_api(
            '/userfiles/change_provider', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userfiles_compress_post(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Compresses many Userfiles each into their own GZIP archive.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_compress_post(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to compress. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userfiles_compress_post_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
        else:
            (data) = self.userfiles_compress_post_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
            return data

    def userfiles_compress_post_with_http_info(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Compresses many Userfiles each into their own GZIP archive.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_compress_post_with_http_info(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to compress. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['multi_userfile_mod_req']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userfiles_compress_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'multi_userfile_mod_req' is set
        if self.api_client.client_side_validation and ('multi_userfile_mod_req' not in params or
                                                       params['multi_userfile_mod_req'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `multi_userfile_mod_req` when calling `userfiles_compress_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'multi_userfile_mod_req' in params:
            body_params = params['multi_userfile_mod_req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BrainPortalSession']  # noqa: E501

        return self.api_client.call_api(
            '/userfiles/compress', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userfiles_delete_files_delete(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Delete several files that have been registered as Userfiles  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_delete_files_delete(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to destroy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userfiles_delete_files_delete_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
        else:
            (data) = self.userfiles_delete_files_delete_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
            return data

    def userfiles_delete_files_delete_with_http_info(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Delete several files that have been registered as Userfiles  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_delete_files_delete_with_http_info(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to destroy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['multi_userfile_mod_req']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userfiles_delete_files_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'multi_userfile_mod_req' is set
        if self.api_client.client_side_validation and ('multi_userfile_mod_req' not in params or
                                                       params['multi_userfile_mod_req'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `multi_userfile_mod_req` when calling `userfiles_delete_files_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'multi_userfile_mod_req' in params:
            body_params = params['multi_userfile_mod_req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BrainPortalSession']  # noqa: E501

        return self.api_client.call_api(
            '/userfiles/delete_files', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userfiles_download_post(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Download several files  # noqa: E501

        This method compresses several Userfiles in .gz format and prepares them to be downloaded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_download_post(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to be downloaded. If more than one file is specified, they will be zipped into a gzip archive. (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userfiles_download_post_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
        else:
            (data) = self.userfiles_download_post_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
            return data

    def userfiles_download_post_with_http_info(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Download several files  # noqa: E501

        This method compresses several Userfiles in .gz format and prepares them to be downloaded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_download_post_with_http_info(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to be downloaded. If more than one file is specified, they will be zipped into a gzip archive. (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['multi_userfile_mod_req']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userfiles_download_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'multi_userfile_mod_req' is set
        if self.api_client.client_side_validation and ('multi_userfile_mod_req' not in params or
                                                       params['multi_userfile_mod_req'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `multi_userfile_mod_req` when calling `userfiles_download_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'multi_userfile_mod_req' in params:
            body_params = params['multi_userfile_mod_req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/*', 'text/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BrainPortalSession']  # noqa: E501

        return self.api_client.call_api(
            '/userfiles/download', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userfiles_get(self, **kwargs):  # noqa: E501
        """List of the Userfiles accessible to the current user.  # noqa: E501

        This method returns a list of Userfiles that are available to the current User.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number when paginating. See also the per_page parameter
        :param int per_page: Size of each page when paginating. See also the page parameter
        :return: list[Userfile]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userfiles_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.userfiles_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def userfiles_get_with_http_info(self, **kwargs):  # noqa: E501
        """List of the Userfiles accessible to the current user.  # noqa: E501

        This method returns a list of Userfiles that are available to the current User.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number when paginating. See also the per_page parameter
        :param int per_page: Size of each page when paginating. See also the page parameter
        :return: list[Userfile]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userfiles_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BrainPortalSession']  # noqa: E501

        return self.api_client.call_api(
            '/userfiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Userfile]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userfiles_id_content_get(self, id, **kwargs):  # noqa: E501
        """Get the content of a Userfile  # noqa: E501

        This method allows you to download the content of a userfile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_id_content_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The ID number of the Userfile to download (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userfiles_id_content_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.userfiles_id_content_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def userfiles_id_content_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the content of a Userfile  # noqa: E501

        This method allows you to download the content of a userfile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_id_content_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The ID number of the Userfile to download (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userfiles_id_content_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `userfiles_id_content_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/*', 'text/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BrainPortalSession']  # noqa: E501

        return self.api_client.call_api(
            '/userfiles/{id}/content', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userfiles_id_get(self, id, **kwargs):  # noqa: E501
        """Get information on a Userfile.  # noqa: E501

        This method returns information about a single Userfile, specified by its ID. Information returned includes the ID of the owner, the Group (project) it is a part of, a description, information about where the acutal copy of the file currently is, and what the status is of any synhronization operations that may have been requested.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The ID number of the Userfile to get information on. (required)
        :return: Userfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userfiles_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.userfiles_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def userfiles_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information on a Userfile.  # noqa: E501

        This method returns information about a single Userfile, specified by its ID. Information returned includes the ID of the owner, the Group (project) it is a part of, a description, information about where the acutal copy of the file currently is, and what the status is of any synhronization operations that may have been requested.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The ID number of the Userfile to get information on. (required)
        :return: Userfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userfiles_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `userfiles_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BrainPortalSession']  # noqa: E501

        return self.api_client.call_api(
            '/userfiles/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Userfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userfiles_id_put(self, id, userfile_mod_req, **kwargs):  # noqa: E501
        """Update information on a Userfile.  # noqa: E501

        This method allows a User to update information on a userfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_id_put(id, userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The ID number of the Userfile to update. (required)
        :param UserfileModReq userfile_mod_req: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userfiles_id_put_with_http_info(id, userfile_mod_req, **kwargs)  # noqa: E501
        else:
            (data) = self.userfiles_id_put_with_http_info(id, userfile_mod_req, **kwargs)  # noqa: E501
            return data

    def userfiles_id_put_with_http_info(self, id, userfile_mod_req, **kwargs):  # noqa: E501
        """Update information on a Userfile.  # noqa: E501

        This method allows a User to update information on a userfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_id_put_with_http_info(id, userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The ID number of the Userfile to update. (required)
        :param UserfileModReq userfile_mod_req: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'userfile_mod_req']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userfiles_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `userfiles_id_put`")  # noqa: E501
        # verify the required parameter 'userfile_mod_req' is set
        if self.api_client.client_side_validation and ('userfile_mod_req' not in params or
                                                       params['userfile_mod_req'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `userfile_mod_req` when calling `userfiles_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'userfile_mod_req' in params:
            body_params = params['userfile_mod_req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BrainPortalSession']  # noqa: E501

        return self.api_client.call_api(
            '/userfiles/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userfiles_post(self, upload_file, data_provider_id, userfile_group_id, file_type, **kwargs):  # noqa: E501
        """Creates a new Userfile and upload its content.  # noqa: E501

        This method creates a new Userfile in CBRAIN, with the current user as the owner of the file.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_post(upload_file, data_provider_id, userfile_group_id, file_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file upload_file: File content to upload to CBRAIN (required)
        :param int data_provider_id: The ID of the Data Provider to upload the file to. (required)
        :param int userfile_group_id: ID of the group that will have access to the Userfile (required)
        :param str file_type: The type of the file (required)
        :param str do_extract: set to the string 'on' to indicate that the uploaded content is a tar.gz or .zip archive that need to be extracted. See also the parameter _up_ex_mode
        :param str up_ex_mode: if '_do_extract' is set to 'on', set this to 'collection' to create a single collection, or 'multiple' to create one file per entry in the uploaded content
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userfiles_post_with_http_info(upload_file, data_provider_id, userfile_group_id, file_type, **kwargs)  # noqa: E501
        else:
            (data) = self.userfiles_post_with_http_info(upload_file, data_provider_id, userfile_group_id, file_type, **kwargs)  # noqa: E501
            return data

    def userfiles_post_with_http_info(self, upload_file, data_provider_id, userfile_group_id, file_type, **kwargs):  # noqa: E501
        """Creates a new Userfile and upload its content.  # noqa: E501

        This method creates a new Userfile in CBRAIN, with the current user as the owner of the file.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_post_with_http_info(upload_file, data_provider_id, userfile_group_id, file_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file upload_file: File content to upload to CBRAIN (required)
        :param int data_provider_id: The ID of the Data Provider to upload the file to. (required)
        :param int userfile_group_id: ID of the group that will have access to the Userfile (required)
        :param str file_type: The type of the file (required)
        :param str do_extract: set to the string 'on' to indicate that the uploaded content is a tar.gz or .zip archive that need to be extracted. See also the parameter _up_ex_mode
        :param str up_ex_mode: if '_do_extract' is set to 'on', set this to 'collection' to create a single collection, or 'multiple' to create one file per entry in the uploaded content
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['upload_file', 'data_provider_id', 'userfile_group_id', 'file_type', 'do_extract', 'up_ex_mode']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userfiles_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'upload_file' is set
        if self.api_client.client_side_validation and ('upload_file' not in params or
                                                       params['upload_file'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `upload_file` when calling `userfiles_post`")  # noqa: E501
        # verify the required parameter 'data_provider_id' is set
        if self.api_client.client_side_validation and ('data_provider_id' not in params or
                                                       params['data_provider_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `data_provider_id` when calling `userfiles_post`")  # noqa: E501
        # verify the required parameter 'userfile_group_id' is set
        if self.api_client.client_side_validation and ('userfile_group_id' not in params or
                                                       params['userfile_group_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `userfile_group_id` when calling `userfiles_post`")  # noqa: E501
        # verify the required parameter 'file_type' is set
        if self.api_client.client_side_validation and ('file_type' not in params or
                                                       params['file_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_type` when calling `userfiles_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'upload_file' in params:
            local_var_files['upload_file'] = params['upload_file']  # noqa: E501
        if 'data_provider_id' in params:
            form_params.append(('data_provider_id', params['data_provider_id']))  # noqa: E501
        if 'userfile_group_id' in params:
            form_params.append(('userfile[group_id]', params['userfile_group_id']))  # noqa: E501
        if 'file_type' in params:
            form_params.append(('file_type', params['file_type']))  # noqa: E501
        if 'do_extract' in params:
            form_params.append(('_do_extract', params['do_extract']))  # noqa: E501
        if 'up_ex_mode' in params:
            form_params.append(('_up_ex_mode', params['up_ex_mode']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BrainPortalSession']  # noqa: E501

        return self.api_client.call_api(
            '/userfiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userfiles_sync_multiple_post(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Syncs Userfiles to the local Data Providers cache.  # noqa: E501

        Synchronizing files to their the local cache allows you to download, visualize and do processing on them that is not available if not synced. CBRAIN operations will sync files automatically, and this is only necessary if a file is changed on its host Data Provdier by an external process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_sync_multiple_post(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to synchronize. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userfiles_sync_multiple_post_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
        else:
            (data) = self.userfiles_sync_multiple_post_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
            return data

    def userfiles_sync_multiple_post_with_http_info(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Syncs Userfiles to the local Data Providers cache.  # noqa: E501

        Synchronizing files to their the local cache allows you to download, visualize and do processing on them that is not available if not synced. CBRAIN operations will sync files automatically, and this is only necessary if a file is changed on its host Data Provdier by an external process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_sync_multiple_post_with_http_info(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to synchronize. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['multi_userfile_mod_req']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userfiles_sync_multiple_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'multi_userfile_mod_req' is set
        if self.api_client.client_side_validation and ('multi_userfile_mod_req' not in params or
                                                       params['multi_userfile_mod_req'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `multi_userfile_mod_req` when calling `userfiles_sync_multiple_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'multi_userfile_mod_req' in params:
            body_params = params['multi_userfile_mod_req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BrainPortalSession']  # noqa: E501

        return self.api_client.call_api(
            '/userfiles/sync_multiple', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def userfiles_uncompress_post(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Uncompresses many Userfiles.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_uncompress_post(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to uncompress. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.userfiles_uncompress_post_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
        else:
            (data) = self.userfiles_uncompress_post_with_http_info(multi_userfile_mod_req, **kwargs)  # noqa: E501
            return data

    def userfiles_uncompress_post_with_http_info(self, multi_userfile_mod_req, **kwargs):  # noqa: E501
        """Uncompresses many Userfiles.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.userfiles_uncompress_post_with_http_info(multi_userfile_mod_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MultiUserfilesModReq multi_userfile_mod_req: The IDs of the files to uncompress. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['multi_userfile_mod_req']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method userfiles_uncompress_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'multi_userfile_mod_req' is set
        if self.api_client.client_side_validation and ('multi_userfile_mod_req' not in params or
                                                       params['multi_userfile_mod_req'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `multi_userfile_mod_req` when calling `userfiles_uncompress_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'multi_userfile_mod_req' in params:
            body_params = params['multi_userfile_mod_req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BrainPortalSession']  # noqa: E501

        return self.api_client.call_api(
            '/userfiles/uncompress', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
